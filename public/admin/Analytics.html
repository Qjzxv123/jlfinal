<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Business Analytics</title>
  <link rel="stylesheet" href="https://unpkg.com/@coreui/icons/css/all.min.css">
  <link rel="stylesheet" href="/Assets/sidebar.css">
  <link rel="icon" type="image/x-icon" href="/Assets/favicon.ico">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.7/dist/umd/supabase.min.js"></script>
  <script src="/Assets/CheckAccess.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #c1de9f 0%, #4dba93 100%);
      margin: 0;
      padding: 0;
      min-height: 100vh;
      color: #333;
    }
    .main-content {
      margin-left: 60px;
      transition: margin-left 0.3s ease;
      min-height: 100vh;
      padding: 32px;
    }
    .header {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.08);
      padding: 24px 32px;
      margin-bottom: 24px;
    }
    .header h1 {
      margin: 0 0 8px 0;
      color: #2c3e50;
      font-size: 2rem;
    }
    .header .subtitle {
      color: #64748b;
      font-size: 0.95rem;
    }
    .filters {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.08);
      padding: 20px 32px;
      margin-bottom: 24px;
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      align-items: center;
    }
    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .filter-group label {
      font-size: 0.85rem;
      color: #64748b;
      font-weight: 600;
    }
    .filter-group select,
    .filter-group input {
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 0.95rem;
      min-width: 150px;
    }
    .btn {
      background: #4DBA93;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 20px;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 600;
      margin-top: auto;
    }
    .btn:hover {
      background: #379c7a;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(77, 186, 147, 0.3);
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }
    .stat-card {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.08);
      padding: 20px;
      transition: transform 0.2s;
      position: relative;
      overflow: hidden;
    }
    .stat-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.12);
    }
    .stat-card .label {
      font-size: 0.85rem;
      color: #64748b;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }
    .stat-card .value {
      font-size: 2rem;
      font-weight: 700;
      color: #2c3e50;
      margin-bottom: 4px;
    }
    .stat-card .subtext {
      font-size: 0.85rem;
      color: #94a3b8;
    }
    .stat-card .pill {
      position: absolute;
      top: 14px;
      right: 14px;
      background: #e7f6ef;
      color: #166534;
      font-weight: 700;
      font-size: 0.75rem;
      padding: 6px 10px;
      border-radius: 999px;
      letter-spacing: 0.5px;
    }
    .chart-container {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.08);
      padding: 28px 32px;
      margin-bottom: 24px;
    }
    .chart-container h2 {
      margin: 0 0 20px 0;
      color: #2c3e50;
      font-size: 1.4rem;
    }
    .chart-container .chart-subtext {
      color: #64748b;
      font-size: 0.9rem;
      margin: -12px 0 16px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    th, td {
      text-align: left;
      padding: 12px 16px;
      border-bottom: 1px solid #e5e7eb;
    }
    th {
      background: #f8fafc;
      color: #475569;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.8rem;
      letter-spacing: 0.5px;
    }
    tr:hover {
      background: #f8fafc;
    }
    .product-rank {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: #e0f2fe;
      color: #0369a1;
      font-weight: 700;
      font-size: 0.85rem;
    }
    .product-rank.top-3 {
      background: #fef3c7;
      color: #92400e;
    }
    .loading {
      text-align: center;
      padding: 60px 20px;
      color: #64748b;
      font-size: 1.1rem;
    }
    .spinner {
      border: 3px solid #e5e7eb;
      border-top: 3px solid #4DBA93;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .platform-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
    }
    .platform-faire {
      background: #fef3c7;
      color: #92400e;
    }
    .platform-shopify {
      background: #dcfce7;
      color: #166534;
    }
    .platform-etsy {
      background: #ffe4e6;
      color: #9f1239;
    }
    .platform-amazon {
      background: #dbeafe;
      color: #1e3a8a;
    }
    .platform-tiktok {
      background: #f3e8ff;
      color: #6b21a8;
    }
    .platform-unknown {
      background: #e2e8f0;
      color: #1e293b;
    }
    .two-column {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
      gap: 24px;
      margin-bottom: 24px;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #e2e8f0;
      color: #1f2937;
      padding: 6px 12px;
      border-radius: 999px;
      font-weight: 600;
      font-size: 0.85rem;
    }
    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }
    .chip {
      background: #ecfeff;
      border: 1px solid #bae6fd;
      color: #0ea5e9;
      padding: 6px 10px;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
    }
    @media (max-width: 768px) {
      .two-column {
        grid-template-columns: 1fr;
      }
      .stats-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div id="sidebar"></div>
  <script src="/Assets/sidebar.js"></script>
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    const initialFilters = {
      dateRange: '30',
      startDate: '',
      endDate: '',
      platform: 'all',
      retailer: 'all',
      returnFilter: 'all'
    };

    const platformColors = {
      'Faire': '#fbbf24',
      'Shopify': '#22c55e',
      'Etsy': '#f43f5e',
      'Amazon': '#3b82f6',
      'TikTok': '#a855f7',
      'Unknown': '#94a3b8'
    };

    function Filters({ filters, retailers, onChange, onApply, onReset }) {
      const isCustomRange = filters.dateRange === 'custom';

      return (
        <div className="filters">
          <div className="filter-group">
            <label>Date Range</label>
            <select
              value={filters.dateRange}
              onChange={(e) => onChange({ ...filters, dateRange: e.target.value })}
            >
              <option value="all">All Time</option>
              <option value="7">Last 7 Days</option>
              <option value="30">Last 30 Days</option>
              <option value="90">Last 90 Days</option>
              <option value="365">Last Year</option>
              <option value="custom">Custom Range</option>
            </select>
          </div>
          {isCustomRange && (
            <>
              <div className="filter-group">
                <label>Start Date</label>
                <input
                  type="date"
                  value={filters.startDate}
                  onChange={(e) => onChange({ ...filters, startDate: e.target.value })}
                />
              </div>
              <div className="filter-group">
                <label>End Date</label>
                <input
                  type="date"
                  value={filters.endDate}
                  onChange={(e) => onChange({ ...filters, endDate: e.target.value })}
                />
              </div>
            </>
          )}
          <div className="filter-group">
            <label>Platform</label>
            <select
              value={filters.platform}
              onChange={(e) => onChange({ ...filters, platform: e.target.value })}
            >
              <option value="all">All Platforms</option>
              <option value="Faire">Faire</option>
              <option value="Shopify">Shopify</option>
              <option value="Etsy">Etsy</option>
              <option value="Amazon">Amazon</option>
              <option value="TikTok">TikTok</option>
            </select>
          </div>
          <div className="filter-group">
            <label>Returns</label>
            <select
              value={filters.returnFilter}
              onChange={(e) => onChange({ ...filters, returnFilter: e.target.value })}
            >
              <option value="all">All Orders</option>
              <option value="exclude">Exclude Returns</option>
              <option value="only">Returned Only</option>
            </select>
          </div>
          <div className="filter-group">
            <label>Retailer</label>
            <select
              value={filters.retailer}
              onChange={(e) => onChange({ ...filters, retailer: e.target.value })}
            >
              <option value="all">All Retailers</option>
              {retailers.map((retailer) => (
                <option key={retailer} value={retailer}>{retailer}</option>
              ))}
            </select>
          </div>
          <div className="filter-group" style={{ marginLeft: 'auto', gap: '10px' }}>
            <button className="btn" onClick={onApply}>Apply Filters</button>
            <button className="btn" style={{ background: '#e2e8f0', color: '#0f172a' }} onClick={onReset}>Reset</button>
          </div>
        </div>
      );
    }

    function StatsGrid({ stats }) {
      const cards = [
        { label: 'Total Orders', value: stats.totalOrders.toLocaleString(), subtext: 'Shipped orders', pill: 'Core' },
        { label: 'Total Shipping Cost', value: `$${stats.totalShippingCost.toFixed(2)}`, subtext: 'Business expense' },
        { label: 'Total Products Sold', value: stats.totalProducts.toLocaleString(), subtext: 'Individual units' },
        { label: 'Avg Shipping Cost', value: `$${stats.avgShippingCost.toFixed(2)}`, subtext: 'Per order' },
        { label: 'Unique Products', value: stats.uniqueProducts.toLocaleString(), subtext: 'SKUs sold' },
        { label: 'Active Retailers', value: stats.activeRetailers.toLocaleString(), subtext: 'With shipped orders' },
        { label: 'Return Rate', value: `${stats.returnRate.toFixed(1)}%`, subtext: `${stats.returnedOrders} returned` },
        { label: 'Returned Units', value: stats.returnedUnits.toLocaleString(), subtext: 'Captured from returns' }
      ];

      return (
        <div className="stats-grid">
          {cards.map((card) => (
            <div key={card.label} className="stat-card">
              <div className="label">{card.label}</div>
              {card.pill && <div className="pill">{card.pill}</div>}
              <div className="value">{card.value}</div>
              <div className="subtext">{card.subtext}</div>
            </div>
          ))}
        </div>
      );
    }

    function ChartCanvas({ title, canvasRef, style }) {
      return (
        <div className="chart-container">
          <h2>{title}</h2>
          <canvas ref={canvasRef} style={style}></canvas>
        </div>
      );
    }

    function FilterSummary({ totalOrders, filteredOrders, filters }) {
      const dateLabel = filters.dateRange === 'custom'
        ? `${filters.startDate || 'Start'} â†’ ${filters.endDate || 'End'}`
        : filters.dateRange === 'all' ? 'All time' : `Last ${filters.dateRange} days`;

      const returnLabel = filters.returnFilter === 'only' ? 'Returned only' : filters.returnFilter === 'exclude' ? 'Excluding returns' : 'Including returns';

      return (
        <div className="chart-container" style={{ marginBottom: 16 }}>
          <h2 style={{ marginBottom: 12 }}>Current View</h2>
          <div className="chips">
            <span className="chip">{dateLabel}</span>
            <span className="chip">{filters.platform === 'all' ? 'All platforms' : filters.platform}</span>
            <span className="chip">{filters.retailer === 'all' ? 'All retailers' : filters.retailer}</span>
            <span className="chip">{returnLabel}</span>
          </div>
          <div className="subtext" style={{ color: '#475569', fontWeight: 600 }}>
            Showing {filteredOrders} of {totalOrders} shipped orders
          </div>
        </div>
      );
    }

    function EmptyState({ message }) {
      return (
        <div className="chart-container" style={{ textAlign: 'center' }}>
          <div className="spinner"></div>
          <div style={{ color: '#475569', fontWeight: 600 }}>{message}</div>
        </div>
      );
    }

    function TopProductsTable({ products }) {
      return (
        <div className="chart-container">
          <h2>Top Products by Quantity</h2>
          <table>
            <thead>
              <tr>
                <th style={{ width: '50px' }}>Rank</th>
                <th>Product SKU</th>
                <th style={{ textAlign: 'right' }}>Quantity</th>
                <th style={{ textAlign: 'right' }}>Orders</th>
              </tr>
            </thead>
            <tbody>
              {products.map((product, idx) => (
                <tr key={product.sku}>
                  <td>
                    <span className={`product-rank ${idx < 3 ? 'top-3' : ''}`}>{idx + 1}</span>
                  </td>
                  <td><strong>{product.sku}</strong></td>
                  <td style={{ textAlign: 'right' }}>{product.totalQty.toLocaleString()}</td>
                  <td style={{ textAlign: 'right' }}>{product.orderCount.toLocaleString()}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }

    function PlatformStatsTable({ stats }) {
      return (
        <div className="chart-container">
          <h2>Platform Breakdown</h2>
          <table>
            <thead>
              <tr>
                <th>Platform</th>
                <th style={{ textAlign: 'right' }}>Orders</th>
                <th style={{ textAlign: 'right' }}>Shipping Cost</th>
                <th style={{ textAlign: 'right' }}>Units</th>
                <th style={{ textAlign: 'right' }}>Return Rate</th>
              </tr>
            </thead>
            <tbody>
              {stats.map((platform) => (
                <tr key={platform.name}>
                  <td><span className={`platform-badge ${platform.badgeClass}`}>{platform.name}</span></td>
                  <td style={{ textAlign: 'right' }}>{platform.orders.toLocaleString()}</td>
                  <td style={{ textAlign: 'right' }}>${platform.shippingCost.toFixed(2)}</td>
                  <td style={{ textAlign: 'right' }}>{platform.units.toLocaleString()}</td>
                  <td style={{ textAlign: 'right' }}>{platform.returnRate.toFixed(1)}%</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }

    function RetailerStatsTable({ stats }) {
      return (
        <div className="chart-container">
          <h2>Retailer Performance</h2>
          <table>
            <thead>
              <tr>
                <th>Retailer</th>
                <th style={{ textAlign: 'right' }}>Orders</th>
                <th style={{ textAlign: 'right' }}>Shipping Cost</th>
                <th style={{ textAlign: 'right' }}>Units Sold</th>
                <th style={{ textAlign: 'right' }}>Avg Order Size</th>
                <th style={{ textAlign: 'right' }}>Returns</th>
                <th style={{ textAlign: 'right' }}>Top Product</th>
              </tr>
            </thead>
            <tbody>
              {stats.map((retailer) => (
                <tr key={retailer.name}>
                  <td><strong>{retailer.name}</strong></td>
                  <td style={{ textAlign: 'right' }}>{retailer.orders.toLocaleString()}</td>
                  <td style={{ textAlign: 'right' }}>${retailer.shippingCost.toFixed(2)}</td>
                  <td style={{ textAlign: 'right' }}>{retailer.units.toLocaleString()}</td>
                  <td style={{ textAlign: 'right' }}>{retailer.avgOrderSize}</td>
                  <td style={{ textAlign: 'right' }}>{retailer.returned.toLocaleString()}</td>
                  <td style={{ textAlign: 'right', fontSize: '0.85rem' }}>{retailer.topProduct}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }

    function ProductsTable({ products, searchTerm, onSearchChange }) {
      return (
        <div className="chart-container">
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 20 }}>
            <h2 style={{ margin: 0 }}>All Products Performance</h2>
            <input
              type="text"
              value={searchTerm}
              onChange={(e) => onSearchChange(e.target.value)}
              placeholder="Search products by SKU or name..."
              style={{ padding: '8px 12px', border: '1px solid #d1d5db', borderRadius: '6px', fontSize: '0.9rem', width: '300px' }}
            />
          </div>
          <table>
            <thead>
              <tr>
                <th>Product SKU</th>
                <th>Name</th>
                <th style={{ textAlign: 'right' }}>Total Quantity</th>
                <th style={{ textAlign: 'right' }}>Times Ordered</th>
                <th style={{ textAlign: 'right' }}>Avg per Order</th>
                <th>Most Common Platform</th>
              </tr>
            </thead>
            <tbody>
              {products.map((product) => (
                <tr key={product.sku}>
                  <td><strong>{product.sku}</strong></td>
                  <td>{product.name}</td>
                  <td style={{ textAlign: 'right' }}>{product.totalQty.toLocaleString()}</td>
                  <td style={{ textAlign: 'right' }}>{product.orderCount.toLocaleString()}</td>
                  <td style={{ textAlign: 'right' }}>{product.avgPerOrder}</td>
                  <td><span className={`platform-badge ${product.badgeClass}`}>{product.platformName}</span></td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }

    function formatToDate(dateString) {
      return new Date(dateString);
    }

    function applyFilterLogic(orders, filters) {
      let filtered = [...orders];

      if (filters.dateRange !== 'all') {
        const now = new Date();
        let startDate;

        if (filters.dateRange === 'custom') {
          if (filters.startDate && filters.endDate) {
            startDate = formatToDate(filters.startDate);
            const endDate = formatToDate(filters.endDate);
            endDate.setHours(23, 59, 59, 999);
            filtered = filtered.filter((order) => {
              const shipDate = new Date(order.ShippedAt);
              return shipDate >= startDate && shipDate <= endDate;
            });
          }
        } else {
          const days = parseInt(filters.dateRange, 10);
          startDate = new Date(now.getTime() - (days * 24 * 60 * 60 * 1000));
          filtered = filtered.filter((order) => new Date(order.ShippedAt) >= startDate);
        }
      }

      if (filters.platform !== 'all') {
        filtered = filtered.filter((order) => order.Platform === filters.platform);
      }

      if (filters.retailer !== 'all') {
        filtered = filtered.filter((order) => order.Retailer === filters.retailer);
      }

      if (filters.returnFilter === 'exclude') {
        filtered = filtered.filter((order) => !order.Returned);
      } else if (filters.returnFilter === 'only') {
        filtered = filtered.filter((order) => order.Returned);
      }

      return filtered;
    }

    function parseItems(rawItems, orderId) {
      if (Array.isArray(rawItems)) return rawItems;
      if (typeof rawItems === 'string') {
        try {
          const parsed = JSON.parse(rawItems);
          return Array.isArray(parsed) ? parsed : [];
        } catch (error) {
          console.warn('Failed to parse Items for order:', orderId, error);
          return [];
        }
      }
      if (rawItems && typeof rawItems === 'object') {
        return Object.values(rawItems);
      }
      return [];
    }

    function deriveAnalytics(orders) {
      const totalOrders = orders.length;
      const totalShippingCost = orders.reduce((sum, order) => sum + (parseFloat(order.ShippingCost) || 0), 0);
      let totalProducts = 0;
      let returnedOrders = 0;
      let returnedUnits = 0;
      const returnReasons = {};
      const productStats = {};
      const platformStats = {};
      const retailerStats = {};

      orders.forEach((order) => {
        const items = parseItems(order.Items, order.OrderID);
        const platform = order.Platform || 'Unknown';
        const retailer = order.Retailer || 'Unknown';
        const shippingCost = parseFloat(order.ShippingCost) || 0;
        const isReturned = Boolean(order.Returned);
        const returnReason = (order.ReturnReason || '').trim() || 'Unspecified';

        if (!platformStats[platform]) {
          platformStats[platform] = { orders: 0, shippingCost: 0, units: 0, returned: 0 };
        }
        platformStats[platform].orders += 1;
        platformStats[platform].shippingCost += shippingCost;
        platformStats[platform].returned += isReturned ? 1 : 0;

        if (!retailerStats[retailer]) {
          retailerStats[retailer] = { orders: 0, shippingCost: 0, units: 0, products: {}, returned: 0 };
        }
        retailerStats[retailer].orders += 1;
        retailerStats[retailer].shippingCost += shippingCost;
        retailerStats[retailer].returned += isReturned ? 1 : 0;

        if (isReturned) {
          returnedOrders += 1;
        }

        items.forEach((item) => {
          const sku = item.SKU || 'Unknown';
          const qty = parseInt(item.Quantity, 10) || 0;
          const name = item.Name || '';

          totalProducts += qty;
          platformStats[platform].units += qty;
          retailerStats[retailer].units += qty;

          if (!productStats[sku]) {
            productStats[sku] = {
              name,
              totalQty: 0,
              orderCount: 0,
              platforms: {}
            };
          }

          productStats[sku].totalQty += qty;
          productStats[sku].orderCount += 1;
          productStats[sku].platforms[platform] = (productStats[sku].platforms[platform] || 0) + 1;

          if (!retailerStats[retailer].products[sku]) {
            retailerStats[retailer].products[sku] = 0;
          }
          retailerStats[retailer].products[sku] += qty;

          if (isReturned) {
            returnedUnits += qty;
            returnReasons[returnReason] = (returnReasons[returnReason] || 0) + qty;
          }
        });
      });

      const avgShippingCost = totalOrders > 0 ? totalShippingCost / totalOrders : 0;
      const uniqueProducts = Object.keys(productStats).length;
      const activeRetailers = Object.keys(retailerStats).length;
      const returnRate = totalOrders > 0 ? (returnedOrders / totalOrders) * 100 : 0;

      const topProducts = Object.entries(productStats)
        .sort((a, b) => b[1].totalQty - a[1].totalQty)
        .slice(0, 20)
        .map(([sku, stats]) => ({ sku, ...stats }));

      const platformTable = Object.entries(platformStats)
        .sort((a, b) => b[1].orders - a[1].orders)
        .map(([name, stats]) => ({
          name,
          badgeClass: `platform-${name.toLowerCase()}`,
          returnRate: stats.orders > 0 ? (stats.returned / stats.orders) * 100 : 0,
          ...stats
        }));

      const retailerTable = Object.entries(retailerStats)
        .sort((a, b) => b[1].orders - a[1].orders)
        .map(([name, stats]) => {
          const topProduct = Object.entries(stats.products).sort((a, b) => b[1] - a[1])[0];
          const topProductText = topProduct ? `${topProduct[0]} (${topProduct[1]})` : 'N/A';
          const avgOrderSize = stats.orders > 0 ? (stats.units / stats.orders).toFixed(1) : '0';
          return { name, topProduct: topProductText, avgOrderSize, ...stats };
        });

      const allProducts = Object.entries(productStats)
        .sort((a, b) => b[1].totalQty - a[1].totalQty)
        .map(([sku, stats]) => {
          const avgPerOrder = stats.orderCount > 0 ? (stats.totalQty / stats.orderCount).toFixed(1) : '0';
          const topPlatform = Object.entries(stats.platforms).sort((a, b) => b[1] - a[1])[0];
          const platformName = topPlatform ? topPlatform[0] : 'Unknown';
          const badgeClass = `platform-${platformName.toLowerCase() || 'unknown'}`;
          return {
            sku,
            name: stats.name,
            totalQty: stats.totalQty,
            orderCount: stats.orderCount,
            avgPerOrder,
            platformName,
            badgeClass
          };
        });

      const dateGroups = {};
      orders.forEach((order) => {
        const date = new Date(order.ShippedAt);
        const dateKey = date.toISOString().split('T')[0];
        dateGroups[dateKey] = (dateGroups[dateKey] || 0) + 1;
      });
      const sortedDates = Object.keys(dateGroups).sort();
      const timelineLabels = sortedDates.map((date) => {
        const d = new Date(date);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });
      const timelineData = sortedDates.map((date) => dateGroups[date]);

      const topProductsChart = Object.entries(productStats)
        .sort((a, b) => b[1].totalQty - a[1].totalQty)
        .slice(0, 10);

      const platformChart = Object.entries(platformStats).sort((a, b) => b[1].orders - a[1].orders);

      const returnChart = Object.entries(returnReasons)
        .sort((a, b) => b[1] - a[1])
        .map(([reason, count]) => ({ reason, count }));

      return {
        totals: {
          totalOrders,
          totalShippingCost,
          totalProducts,
          avgShippingCost,
          uniqueProducts,
          activeRetailers,
          returnedOrders,
          returnedUnits,
          returnRate
        },
        topProducts,
        platformTable,
        retailerTable,
        allProducts,
        ordersTimeline: { labels: timelineLabels, data: timelineData },
        topProductsChart,
        platformChart,
        returnChart
      };
    }

    function useCharts(analytics) {
      const ordersTimelineRef = useRef(null);
      const topProductsRef = useRef(null);
      const platformPieRef = useRef(null);
      const returnsChartRef = useRef(null);
      const chartInstances = useRef({});

      useEffect(() => {
        const destroyChart = (name) => {
          if (chartInstances.current[name]) {
            chartInstances.current[name].destroy();
            delete chartInstances.current[name];
          }
        };

        const renderOrdersTimeline = () => {
          if (!ordersTimelineRef.current) return;
          destroyChart('ordersTimeline');
          chartInstances.current.ordersTimeline = new Chart(ordersTimelineRef.current, {
            type: 'line',
            data: {
              labels: analytics.ordersTimeline.labels,
              datasets: [{
                label: 'Orders Shipped',
                data: analytics.ordersTimeline.data,
                borderColor: '#4DBA93',
                backgroundColor: 'rgba(77, 186, 147, 0.1)',
                tension: 0.3,
                fill: true,
                pointRadius: 3,
                pointHoverRadius: 5
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (context) => `Orders: ${context.parsed.y}`
                  }
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  ticks: { stepSize: 1 }
                }
              }
            }
          });
        };

        const renderTopProducts = () => {
          if (!topProductsRef.current) return;
          destroyChart('topProducts');
          const labels = analytics.topProductsChart.map(([sku]) => sku);
          const data = analytics.topProductsChart.map(([, stats]) => stats.totalQty);
          chartInstances.current.topProducts = new Chart(topProductsRef.current, {
            type: 'bar',
            data: {
              labels,
              datasets: [{
                label: 'Quantity Sold',
                data,
                backgroundColor: [
                  '#4DBA93', '#5CC6A1', '#6FD2AF', '#82DEBD', '#95EACB',
                  '#A8F6D9', '#88D9B8', '#70CC9F', '#58BF86', '#40B26D'
                ],
                borderRadius: 6
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              indexAxis: 'y',
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (context) => `Quantity: ${context.parsed.x.toLocaleString()}`
                  }
                }
              },
              scales: {
                x: { beginAtZero: true }
              }
            }
          });
        };

        const renderPlatformPie = () => {
          if (!platformPieRef.current) return;
          destroyChart('platformPie');
          const labels = analytics.platformChart.map(([platform]) => platform);
          const data = analytics.platformChart.map(([, stats]) => stats.orders);
          const backgroundColor = labels.map((label) => platformColors[label] || '#94a3b8');
          chartInstances.current.platformPie = new Chart(platformPieRef.current, {
            type: 'doughnut',
            data: {
              labels,
              datasets: [{
                data,
                backgroundColor,
                borderWidth: 2,
                borderColor: '#fff'
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              plugins: {
                legend: {
                  position: 'right',
                  labels: { padding: 15, font: { size: 12 } }
                },
                tooltip: {
                  callbacks: {
                    label: (context) => {
                      const label = context.label || '';
                      const value = context.parsed || 0;
                      const total = context.dataset.data.reduce((a, b) => a + b, 0);
                      const percentage = total ? ((value / total) * 100).toFixed(1) : '0.0';
                      return `${label}: ${value} orders (${percentage}%)`;
                    }
                  }
                }
              }
            }
          });
        };

        const renderReturnsChart = () => {
          if (!returnsChartRef.current || analytics.returnChart.length === 0) return;
          destroyChart('returns');
          chartInstances.current.returns = new Chart(returnsChartRef.current, {
            type: 'bar',
            data: {
              labels: analytics.returnChart.map((item) => item.reason),
              datasets: [{
                label: 'Units Returned',
                data: analytics.returnChart.map((item) => item.count),
                backgroundColor: '#fda4af',
                borderRadius: 6
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (context) => `${context.parsed.y.toLocaleString()} units`
                  }
                }
              },
              scales: {
                y: { beginAtZero: true }
              }
            }
          });
        };

        renderOrdersTimeline();
        renderTopProducts();
        renderPlatformPie();
        renderReturnsChart();

        return () => {
          destroyChart('ordersTimeline');
          destroyChart('topProducts');
          destroyChart('platformPie');
          destroyChart('returns');
        };
      }, [analytics]);

      return { ordersTimelineRef, topProductsRef, platformPieRef, returnsChartRef };
    }

    function AnalyticsApp() {
      const [filters, setFilters] = useState(initialFilters);
      const [appliedFilters, setAppliedFilters] = useState(initialFilters);
      const [retailers, setRetailers] = useState([]);
      const [allOrders, setAllOrders] = useState([]);
      const [loading, setLoading] = useState(true);
      const [searchTerm, setSearchTerm] = useState('');
      const [error, setError] = useState('');

      useEffect(() => {
        checkPermissions(['service_role', 'employee']).then(() => {
          setupInactivityTimeout(5);
        }).catch((error) => console.error(error));

        const loadData = async () => {
          await loadRetailers();
          await loadOrders();
        };

        loadData();
      }, []);

      const loadRetailers = async () => {
        const { data, error } = await supabase
          .from('Order History')
          .select('Retailer')
          .not('Retailer', 'is', null);

        if (!error && data) {
          const uniqueRetailers = Array.from(new Set(data.map((entry) => entry.Retailer))).sort();
          setRetailers(uniqueRetailers);
        } else if (error) {
          setError(error.message);
        }
      };

      const loadOrders = async () => {
        setLoading(true);
        let allData = [];
        let from = 0;
        const pageSize = 1000;

        while (true) {
          const { data, error } = await supabase
            .from('Order History')
            .select('*')
            .neq('TrackingNumber', null)
            .range(from, from + pageSize - 1)
            .order('ShippedAt', { ascending: false });

          if (error) {
            console.error('Error loading order history:', error);
            setError(error.message);
            break;
          }

          if (!data || data.length === 0) break;
          allData = allData.concat(data);
          if (data.length < pageSize) break;
          from += pageSize;
        }

        setAllOrders(allData);
        setLoading(false);
      };

      const filteredOrders = useMemo(
        () => applyFilterLogic(allOrders, appliedFilters),
        [allOrders, appliedFilters]
      );

      const analytics = useMemo(() => deriveAnalytics(filteredOrders), [filteredOrders]);

      const { ordersTimelineRef, topProductsRef, platformPieRef, returnsChartRef } = useCharts(analytics);

      const filteredProducts = useMemo(() => {
        if (!searchTerm) return analytics.allProducts;
        const term = searchTerm.toLowerCase();
        return analytics.allProducts.filter((product) =>
          (product.sku || '').toLowerCase().includes(term) ||
          (product.name || '').toLowerCase().includes(term)
        );
      }, [analytics.allProducts, searchTerm]);

      const handleResetFilters = () => {
        setFilters(initialFilters);
        setAppliedFilters(initialFilters);
        setSearchTerm('');
      };

      const exportCsv = () => {
        const headers = ['OrderID', 'Retailer', 'Platform', 'ShippedAt', 'ShippingCost', 'Returned', 'ReturnReason', 'Items'];
        const rows = filteredOrders.map((order) => {
          const items = parseItems(order.Items, order.OrderID)
            .map((item) => `${item.SKU || ''}:${item.Quantity || ''}`)
            .join('; ');
          return [
            order.OrderID,
            order.Retailer || '',
            order.Platform || '',
            order.ShippedAt || '',
            order.ShippingCost || '',
            order.Returned ? 'Yes' : 'No',
            order.ReturnReason || '',
            items
          ];
        });

        const csv = [headers, ...rows]
          .map((row) => row.map((value) => `"${String(value ?? '').replace(/"/g, '""')}"`).join(','))
          .join('\n');

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'analytics-orders.csv';
        link.click();
        URL.revokeObjectURL(url);
      };

      return (
        <div className="main-content">
          <div className="header">
            <h1>Business Analytics</h1>
            <div className="subtitle">Product statistics and insights from order history</div>
            <div style={{ display: 'flex', gap: 10, marginTop: 12, flexWrap: 'wrap' }}>
              <span className="badge">Orders: {filteredOrders.length.toLocaleString()}</span>
              <span className="badge">Products: {analytics.totals.uniqueProducts.toLocaleString()}</span>
              <span className="badge">Retailers: {analytics.totals.activeRetailers.toLocaleString()}</span>
              <button className="btn" onClick={exportCsv}>Export CSV</button>
            </div>
          </div>

          <Filters
            filters={filters}
            retailers={retailers}
            onChange={setFilters}
            onApply={() => setAppliedFilters(filters)}
            onReset={handleResetFilters}
          />

          {loading ? (
            <div className="loading">
              <div className="spinner"></div>
              Loading analytics data...
            </div>
          ) : (
            <div id="analyticsContent">
              {error && <EmptyState message={`Supabase error: ${error}`} />}

              <FilterSummary
                totalOrders={allOrders.length}
                filteredOrders={filteredOrders.length}
                filters={appliedFilters}
              />

              {filteredOrders.length === 0 ? (
                <EmptyState message="No orders match the current filters." />
              ) : (
                <>
                  <StatsGrid stats={analytics.totals} />

                  <ChartCanvas title="Orders Over Time" canvasRef={ordersTimelineRef} style={{ maxHeight: '300px' }} />

                  <div className="two-column">
                    <ChartCanvas title="Top 10 Products" canvasRef={topProductsRef} style={{ maxHeight: '350px' }} />
                    <ChartCanvas title="Platform Distribution" canvasRef={platformPieRef} style={{ maxHeight: '350px' }} />
                  </div>

                  {analytics.returnChart.length > 0 && (
                    <ChartCanvas title="Returns by Reason" canvasRef={returnsChartRef} style={{ maxHeight: '320px' }} />
                  )}

                  <div className="two-column">
                    <TopProductsTable products={analytics.topProducts} />
                    <PlatformStatsTable stats={analytics.platformTable} />
                  </div>

                  <RetailerStatsTable stats={analytics.retailerTable} />

                  <ProductsTable
                    products={filteredProducts}
                    searchTerm={searchTerm}
                    onSearchChange={setSearchTerm}
                  />
                </>
              )}
            </div>
          )}
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<AnalyticsApp />);
  </script>
</body>
</html>
